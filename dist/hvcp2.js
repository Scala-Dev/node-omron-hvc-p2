/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/HvcP2.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/HvcP2.js":
/*!**********************!*\
  !*** ./lib/HvcP2.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* ------------------------------------------------------------------\r\n* node-omron-hvc-p2 - HvcP2.js\r\n* Date: 2018-02-14\r\n* ---------------------------------------------------------------- */\n\n\nconst mFs = __webpack_require__(/*! fs */ \"fs\");\nconst mOs = __webpack_require__(/*! os */ \"os\");\nconst mPath = __webpack_require__(/*! path */ \"path\");\nconst mSerialPort = __webpack_require__(/*! serialport */ \"serialport\");\nconst mHvcP2Command = __webpack_require__(/*! ./HvcP2Command.js */ \"./lib/HvcP2Command.js\");\n\nconst libVer = \"v0.1.5a\";\n// const { performance } = require('perf_hooks');\n\n/*\r\nconst perfMarkers = {\r\n  serialPort: {\r\n    begin: 'open-serial-port-begin',\r\n    end: 'open-serial-port-end',\r\n    label: 'open-serial-port-begin to open-serial-port-end'\r\n  },\r\n  deviceConnect: {\r\n    begin: 'device-connect-begin',\r\n    end: 'device-connect-end',\r\n    label: 'device-connect-begin to device-connect-end'\r\n  },\r\n  deviceRequest: {\r\n    begin: 'open-device-request-begin',\r\n    end: 'open-device-request-end',\r\n    label: 'open-device-request-begin to open-device-request-end'\r\n  },\r\n  configurations: {\r\n    begin: 'get-configurations-begin',\r\n    end: 'get-configurations-end',\r\n    label: 'get-configurations-begin to get-configurations-end',\r\n    endWithNoCache: 'get-configurations-no-cache-end',\r\n    labelWithNoCache: 'get-configurations-begin to get-configurations-no-cache-end'\r\n  },\r\n  detect: {\r\n    begin: 'detect-begin',\r\n    end: 'detect-end',\r\n    label: 'detect-begin to detect-end'\r\n  }\r\n};\r\n*/\n\n/* ------------------------------------------------------------------\r\n* Constructor: HvcP2()\r\n* ---------------------------------------------------------------- */\nconst HvcP2 = function () {\n\t// Public properties\n\n\t// Private properties\n\tthis._port = null;\n\tthis._connected = false;\n\tthis._ondata = () => {};\n\tthis._request_timer = null;\n\tthis._user_id_list = [];\n\tthis._configurations = {};\n\tthis._DEFAULT_CONFIGURATIONS = {\n\t\tcameraAngle: {\n\t\t\tangle: 0\n\t\t},\n\t\tthreshold: {\n\t\t\tbody: 500,\n\t\t\thand: 500,\n\t\t\tface: 500,\n\t\t\trecognition: 500\n\t\t},\n\t\tdetectionSize: {\n\t\t\tbodyMin: 30,\n\t\t\tbodyMax: 8192,\n\t\t\thandMin: 40,\n\t\t\thandMax: 8192,\n\t\t\tfaceMin: 64,\n\t\t\tfaceMax: 8192\n\t\t},\n\t\tfaceAngle: {\n\t\t\tyaw: 0,\n\t\t\troll: 0\n\t\t}\n\t};\n\tthis._MODEL_NAME = 'B5T-007001';\n\tthis._serial_port_path = '';\n\tthis._model = {};\n};\n\nHvcP2.prototype.version = function () {\n\treturn libVer;\n};\n\nHvcP2.prototype.connected = function () {\n\treturn this._connected;\n};\n\n/*\r\nHvcP2.prototype.dumpPerformance = function() {\r\n\tthis._writePerformanceLine(perfMarkers.serialPort.label);\r\n\tthis._writePerformanceLine(perfMarkers.deviceConnect.label);\r\n\tthis._writePerformanceLine(perfMarkers.configurations.label);\r\n\tthis._writePerformanceLine(perfMarkers.configurations.labelWithNoCache);\r\n\tthis._writePerformanceLine(perfMarkers.deviceRequest.label);\r\n\tthis._writePerformanceLine(perfMarkers.detect.label);\t\r\n};\r\n\r\nHvcP2.prototype._writePerformanceLine = function(label) {\r\n\tconst measurements = performance.getEntriesByName(label);\r\n\tconst average = measurements.reduce((total, measurement) => total + measurement.duration, 0) / measurements.length;\r\n\tconsole.log('');\r\n\tconsole.log('- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -');\r\n\tconsole.log(`${measurements.length} count for ${label}, average of: ${average}`);\r\n};\r\n*/\n\n/* ------------------------------------------------------------------\r\n* Method: connect([params])\r\n* - params     | optional | Object |\r\n*   - path     | optional | String | e.g., \"COM3\", \"/dev/tty-usbserial1\"\r\n*   - baudRate | optional | Number | 9600, 38400, 115200, 230400, 460800, or 921600 (Default)\r\n*   - perflog | optional | boolean | Enable/disable performance logging...\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.connect = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\n\t\t/*\r\n  let perfCheck = false;\r\n  if('perflog' in params) {\r\n  \tperfCheck = params['perflog'];\r\n  \tif(typeof(perfCheck) !== 'boolean') {\r\n  \t\treject(new Error('The parameter `perflog` must be a boolean.'));\r\n  \t\treturn;\r\n  \t}\r\n  }\r\n  \t\tif(perfCheck !== false) {\r\n  \tperformance.mark(perfMarkers.deviceConnect.begin);\r\n  }\r\n  */\n\n\t\tif (params && typeof params !== 'object') {\n\t\t\treject(new Error('Invaid parameter.'));\n\t\t\treturn;\n\t\t} else {\n\t\t\tparams = {};\n\t\t}\n\t\t// Check the parameter `path`\n\t\tlet path = '';\n\t\tif ('path' in params) {\n\t\t\tpath = params['path'];\n\t\t\tif (typeof path !== 'string') {\n\t\t\t\treject(new Error('The parameter `path` must be a string.'));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Check the parameter `baudRate`\n\t\tlet rate = 921600;\n\t\tif ('baudRate' in params) {\n\t\t\trate = params['baudRate'];\n\t\t\tif (typeof rate !== 'number') {\n\t\t\t\treject(new Error('The parameter `baudRate` must be a number.'));\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif (!rate.toString().match(/^9600|38400|115200|230400|460800|921600$/)) {\n\t\t\t\t\treject(new Error('The parameter `baudRate` must be 9600, 38400, 115200, 230400, 460800, or 921600.'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Open the serial port\n\t\tthis._openSerialPort({\n\t\t\tpath: path,\n\t\t\tbaudRate: rate\n\t\t}).then(() => {\n\t\t\treturn this.getConfigurations({ cache: false });\n\t\t}).then(() => {\n\t\t\treturn this.getFaceRecognitionUsers({ cache: false });\n\t\t}).then(() => {\n\t\t\t/*\r\n   if(perfCheck !== false) {\r\n   \tperformance.mark(perfMarkers.deviceConnect.end);\r\n   \tperformance.measure(perfMarkers.deviceConnect.label, perfMarkers.deviceConnect.begin, perfMarkers.deviceConnect.end);\r\n   }\r\n   */\n\t\t\tresolve();\n\t\t}).catch(error => {\n\t\t\t//console.log(\"107:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\nHvcP2.prototype._openSerialPort = function (p) {\n\tlet promise = new Promise((resolve, reject) => {\n\n\t\t// performance.mark(perfMarkers.serialPort.begin);\n\n\t\tif (this._connected === true) {\n\t\t\tresolve();\n\t\t\treturn;\n\t\t}\n\t\tmSerialPort.list().then(com_list => {\n\t\t\tlet candidate_com_list = [];\n\t\t\tlet pf = mOs.platform();\n\t\t\tif (p['path']) {\n\t\t\t\tcom_list.forEach(com => {\n\t\t\t\t\tif (com.comName === path) {\n\t\t\t\t\t\tcandidate_com_list.push(com);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (pf === 'linux') {\n\t\t\t\t// ------------------------------------------------\n\t\t\t\t// * linux\n\t\t\t\t// {\n\t\t\t\t//   \"manufacturer\": \"OMRON Corporation\",\n\t\t\t\t//   \"serialNumber\": \"1\",\n\t\t\t\t//   \"pnpId\": \"usb-OMRON_Corporation_OMRON_HVC-P2_1-if00\",\n\t\t\t\t//   \"vendorId\": \"0590\",\n\t\t\t\t//   \"productId\": \"OMRON HVC-P2\", or \"00ca\"\n\t\t\t\t//   \"comName\": \"/dev/ttyACM0\"\n\t\t\t\t// }\n\t\t\t\t// ------------------------------------------------\n\t\t\t\tcom_list.forEach(com => {\n\t\t\t\t\tif (com.manufacturer && com.manufacturer.match(/OMRON/, 'i') && com.vendorId && com.vendorId.match(/0590/) && com.productId && com.productId.match(/(HVC\\-P2|00ca)/, 'i')) {\n\t\t\t\t\t\tcandidate_com_list.push(com);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (pf === 'win32') {\n\t\t\t\t// ------------------------------------------------\n\t\t\t\t// * win32\n\t\t\t\t// {\n\t\t\t\t//   \"comName\": \"COM4\",\n\t\t\t\t//   \"manufacturer\": \"Microsoft\",\n\t\t\t\t//   \"serialNumber\": \"1\",\n\t\t\t\t//   \"pnpId\": \"USB\\\\VID_0590&PID_00CA\\\\1\",\n\t\t\t\t//   \"locationId\": \"Port_#0002.Hub_#0009\",\n\t\t\t\t//   \"vendorId\": \"0590\",\n\t\t\t\t//   \"productId\": \"00CA\"\n\t\t\t\t// }\n\t\t\t\t// ------------------------------------------------\n\t\t\t\tcom_list.forEach(com => {\n\t\t\t\t\tif (com.vendorId && com.vendorId.match(/0590/) && com.productId && com.productId.match(/00CA/, 'i')) {\n\t\t\t\t\t\tcandidate_com_list.push(com);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (pf === 'darwin') {\n\t\t\t\t// ------------------------------------------------\n\t\t\t\t// * darwin\n\t\t\t\t// {\n\t\t\t\t//   \"comName\": \"/dev/tty.usbmodem1\",\n\t\t\t\t//   \"manufacturer\": \"OMRON Corporation\",\n\t\t\t\t//   \"serialNumber\": \"1\",\n\t\t\t\t//   \"locationId\": \"14110000\",\n\t\t\t\t//   \"vendorId\": \"0590\",\n\t\t\t\t//   \"productId\": \"00ca\"\n\t\t\t\t// }\n\t\t\t\t// ------------------------------------------------\n\t\t\t\tcom_list.forEach(com => {\n\t\t\t\t\tif (com.comName.match(/usb/) && com.manufacturer && com.manufacturer.match(/OMRON/, 'i') && com.vendorId && com.vendorId.match(/0590/) && com.productId && com.productId.match(/00ca/, 'i')) {\n\t\t\t\t\t\tcandidate_com_list.push(com);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn this._tryOpenSerialPort(p['baudRate'], candidate_com_list);\n\t\t}).then(() => {\n\t\t\t/*\r\n   performance.mark(perfMarkers.serialPort.open_end);\r\n   performance.measure(perfMarkers.serialPort.label, perfMarkers.serialPort.open_begin, perfMarkers.serialPort.open_end);\r\n   */\n\t\t\tresolve();\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"186:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\nHvcP2.prototype._tryOpenSerialPort = function (baud_rate, com_list) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tlet e = null;\n\t\tlet tryConnect = callback => {\n\t\t\tlet com = com_list.shift();\n\t\t\tif (!com) {\n\t\t\t\tcallback(e || new Error('No device was found.'));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet path = com.comName;\n\t\t\tlet port = new mSerialPort(path, {\n\t\t\t\tbaudRate: baud_rate\n\t\t\t});\n\t\t\tport.once('error', error => {\n\t\t\t\te = error;\n\t\t\t\tthis._connected = false;\n\t\t\t\tport = null;\n\t\t\t\ttryConnect(callback);\n\t\t\t});\n\t\t\tport.once('open', () => {\n\t\t\t\tthis._initSerialPort(port);\n\t\t\t\tthis.request(0x00, null).then(res => {\n\t\t\t\t\tif (res['model'] === this._MODEL_NAME) {\n\t\t\t\t\t\tthis._model = JSON.parse(JSON.stringify(res));\n\t\t\t\t\t\tcallback(null, path);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tport.close(() => {\n\t\t\t\t\t\t\tport = null;\n\t\t\t\t\t\t\ttryConnect(callback);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}).catch(error => {\n\t\t\t\t\tconsole.log(\"226:\");\n\t\t\t\t\tconsole.log(error);\n\t\t\t\t\ttryConnect(callback);\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t\ttryConnect((error, path) => {\n\t\t\tif (error) {\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tthis._serial_port_path = path;\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n\treturn promise;\n};\n\nHvcP2.prototype._initSerialPort = function (port) {\n\tthis._connected = true;\n\tthis._port = port;\n\tthis._port.on('data', buf => {\n\t\tthis._ondata(buf);\n\t});\n\tthis._port.once('close', () => {\n\t\tthis._port.removeAllListeners('data');\n\t\tthis._connected = false;\n\t\tthis._port = null;\n\t\tthis._serial_port_path = '';\n\t});\n};\n\n/* ------------------------------------------------------------------\r\n* Method: disconnect()\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.disconnect = function () {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tif (this._port && this._connected === true) {\n\t\t\tthis._port.close(() => {\n\t\t\t\tresolve();\n\t\t\t});\n\t\t} else {\n\t\t\tresolve();\n\t\t}\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: getSerialPortPath()\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.getSerialPortPath = function () {\n\treturn this._serial_port_path;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: request(cn, params)\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.request = function (cn, params) {\n\tlet promise = new Promise((resolve, reject) => {\n\n\t\tif (cn === 4) {\n\t\t\t// 4 == detect.. we only want to measure requests to the device that are actual detections\n\t\t\t// performance.mark(perfMarkers.deviceRequest.begin);\n\t\t}\n\n\t\tif (this._connected !== true) {\n\t\t\treject(new Error('The device is not connected.'));\n\t\t\treturn;\n\t\t}\n\t\tif (this._request_timer) {\n\t\t\treject(new Error('The previous process is running.'));\n\t\t\treturn;\n\t\t}\n\t\tlet cmd = mHvcP2Command.create(cn, params);\n\t\tif (cmd['error']) {\n\t\t\treject(cmd['error']);\n\t\t\treturn;\n\t\t}\n\t\tlet timeout = 1000;\n\t\tif (cn === 0x04) {\n\t\t\ttimeout = 30000;\n\t\t} else if (cn === 0x22) {\n\t\t\ttimeout = 5000;\n\t\t} else if (cn === 0x30) {\n\t\t\ttimeout = 10000;\n\t\t}\n\t\tthis._request_timer = setTimeout(() => {\n\t\t\tthis._request_timer = null;\n\t\t\tconsole.log(\"Took too long...\");\n\t\t\t// Dammit - whats a better way to handle this to prevent entire thing from crapping out....\n\t\t\treject(new Error('Timeout'));\n\t\t}, timeout);\n\n\t\tlet data_length = 0;\n\t\tlet received_length = 0;\n\t\tlet chunk_list = [];\n\n\t\tthis._ondata = chunk => {\n\t\t\t// performance.mark(perfMarkers.deviceRequest.begin);\n\t\t\tif (received_length === 0) {\n\t\t\t\t//console.log(chunk.length);\n\t\t\t\t// console.log(chunk.readUInt8(0));\n\t\t\t\tif (chunk.readUInt8(0) === 0xFE && chunk.length >= 6) {\n\t\t\t\t\tdata_length = chunk.readUInt32LE(2);\n\t\t\t\t} else {\n\t\t\t\t\t//console.log(\"Weird Image Chunk...\");\n\t\t\t\t\t//console.log(chunk.length);\n\t\t\t\t\tchunk = [];\n\t\t\t\t\treject(new Error('Unknown data………'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunk_list.push(chunk);\n\t\t\treceived_length += chunk.length;\n\t\t\tif (received_length >= data_length) {\n\t\t\t\tthis._ondata = () => {};\n\t\t\t\tclearTimeout(this._request_timer);\n\t\t\t\tthis._request_timer = null;\n\t\t\t\tlet buf = Buffer.concat(chunk_list);\n\t\t\t\tlet res = mHvcP2Command.parse(cn, buf, params);\n\t\t\t\tif (res['error']) {\n\t\t\t\t\tchunk_list = [];\n\t\t\t\t\tchunk = [];\n\t\t\t\t\treject(res['error']);\n\t\t\t\t} else {\n\t\t\t\t\tif (cn === 4) {\n\t\t\t\t\t\t// 4 == detect.. we only want to measure requests to the device that are actual detections\n\t\t\t\t\t\t/*\r\n      performance.mark(perfMarkers.deviceRequest.end);\r\n          \t\t\t\tperformance.measure(perfMarkers.deviceRequest.label, perfMarkers.deviceRequest.begin, perfMarkers.deviceRequest.end);\r\n          \t\t\t\tperformance.mark(perfMarkers.deviceRequest.begin);\r\n      */\n\t\t\t\t\t}\n\t\t\t\t\tchunk_list = [];\n\t\t\t\t\tchunk = [];\n\t\t\t\t\tresolve(res['data']);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis._port.write(cmd['buffer']);\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: getModelVersion([params])\r\n* - params  | optional | Object  |\r\n*   - cache | optional | Boolean | true (default) or false\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.getModelVersion = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tlet cache = true;\n\t\tif (params && typeof params === 'object') {\n\t\t\tif ('cache' in params) {\n\t\t\t\tlet v = params['cache'];\n\t\t\t\tif (typeof v === 'boolean') {\n\t\t\t\t\tcache = v;\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error('The parameter `cache` must be Boolean.'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cache === true) {\n\t\t\tconsole.log('cached');\n\t\t\tresolve(JSON.parse(JSON.stringify(this._model)));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.request(0x00, null).then(res => {\n\t\t\tresolve(res);\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"372:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: detect(params)\r\n* - params        | required    | Object  |\r\n*   - body        | optional    | Number  | Human Body Detection (0: disable (default), 1: enable)\r\n*   - hand        | optional    | Number  | Hand Detection (0: disable (default), 1: enable)\r\n*   - face        | optional    | Number  | Face Detection (0: disable (default), 1: enable)\r\n*   - direction   | optional    | Number  | Face Direction Estimation (0: disable (default), 1: enable)\r\n*   - age         | optional    | Number  | Age Estimation (0: disable (default), 1: enable)\r\n*   - gender      | optional    | Number  | Gender Estimation (0: disable (default), 1: enable)\r\n*   - gaze        | optional    | Number  | Gaze Estimation (0: disable (default), 1: enable)\r\n*   - blink       | optional    | Number  | Blink Estimation (0: disable (default), 1: enable)\r\n*   - expression  | optional    | Number  | Expression Estimation (0: disable (default), 1: enable)\r\n*   - recognition | optional    | Number  | Face Recognition (0: disable (default), 1: enable)\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.detect = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tthis.request(0x04, params).then(res => {\n\t\t\tresolve(res);\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"436:\");\n\t\t\tconsole.log(error);\n\t\t\t//resolve();\n\t\t\t//resolve({data: {}})\n\t\t\t// do we resolve or reject this one to avoid bubbling errors during prod?\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: getConfigurations([params])\r\n* - params  | optional | Object  |\r\n*   - cache | optional | Boolean | true (default) or false\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.getConfigurations = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\n\t\t//performance.mark(perfMarkers.configurations.begin);\n\n\t\tlet cache = true;\n\t\tif (params && typeof params === 'object') {\n\t\t\tif ('cache' in params) {\n\t\t\t\tlet v = params['cache'];\n\t\t\t\tif (typeof v === 'boolean') {\n\t\t\t\t\tcache = v;\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error('The parameter `cache` must be Boolean.'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cache === true) {\n\t\t\tlet returnObject = JSON.parse(JSON.stringify(this._configurations));\n\t\t\t/*\r\n   performance.mark(perfMarkers.configurations.end);\r\n   performance.measure(perfMarkers.configurations.label, perfMarkers.configurations.begin, perfMarkers.configurations.end);\r\n   */\n\t\t\tresolve(returnObject);\n\t\t\treturn;\n\t\t}\n\t\tlet c = {};\n\t\t// Get Camera Angle\n\t\tthis.request(0x02).then(res => {\n\t\t\tc['cameraAngle'] = res;\n\t\t\t// Get Threshold Values\n\t\t\treturn this.request(0x06);\n\t\t}).then(res => {\n\t\t\tc['threshold'] = res;\n\t\t\t// Get Detection Size\n\t\t\treturn this.request(0x08);\n\t\t}).then(res => {\n\t\t\tc['detectionSize'] = res;\n\t\t\t// Get Face Angle\n\t\t\treturn this.request(0x0A);\n\t\t}).then(res => {\n\t\t\tc['faceAngle'] = res;\n\t\t\tthis._configurations = c;\n\n\t\t\tlet returnObject = JSON.parse(JSON.stringify(c));\n\t\t\t/*\r\n   performance.mark(perfMarkers.configurations.endWithNoCache);\r\n   performance.measure(perfMarkers.configurations.labelWithNoCache, perfMarkers.configurations.begin, perfMarkers.configurations.endWithNoCache);\t\t\t\r\n   */\n\t\t\tresolve(returnObject);\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"486:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: setConfigurations(configrations)\r\n* - configurations  | required | Object |\r\n*   - cameraAngle   | optional | Object | Camera Angle\r\n*     - angle       | optional | Number | 0: 0º, 1: 90º, 2: 180º, 3: 270º\r\n*   - threshold     | optional | Object | Threshold Values\r\n*     - body        | optional | Number | Human Body Detection threshold (1 - 1000)\r\n*     - hand        | optional | Number | Hand Detection threshold (1 - 1000)\r\n*     - face        | optional | Number | Face Detection threshold (1 - 1000)\r\n*     - recognition | optional | Number | Face Recognition threshold (0 - 1000)\r\n*   - detectionSize | optional | Object | Detection Size\r\n*     - bodyMin     | optional | Number | Human Body Detection minimum size (20 - 8192)\r\n*     - bodyMax     | optional | Number | Human Body Detection maximum size (20 - 8192)\r\n*     - handMin     | optional | Number | Hand Detection minimum size (20 - 8192)\r\n*     - handMax     | optional | Number | Hand Detection maximum size (20 - 8192)\r\n*     - faceMin     | optional | Number | Face Detection minimum size (20 - 8192)\r\n*     - faceMax     | optional | Number | Face Detection maximum size (20 - 8192)\r\n*   - faceAngle     | optional | Object | Face Angle Range\r\n*     - yaw         | optional | Number | Yaw angle range (0: ±30º, 1: ±60º, 2: ±90º)\r\n*     - roll        | optional | Number | Roll angle range (0: ±15º, 1: ±45º)\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.setConfigurations = function (configurations) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tif (!configurations || typeof configurations !== 'object') {\n\t\t\treject(new Error('The argument `configurations` is invalid.'));\n\t\t\treturn;\n\t\t}\n\t\tlet update_conf = {};\n\t\t// Get the current configurations\n\t\tthis.getConfigurations().then(current_conf => {\n\t\t\t['cameraAngle', 'threshold', 'detectionSize', 'faceAngle'].forEach(k => {\n\t\t\t\tif (k in configurations && typeof configurations[k] === 'object') {\n\t\t\t\t\tlet update_prop_num = 0;\n\t\t\t\t\tlet o = {};\n\t\t\t\t\tfor (var prop in this._configurations[k]) {\n\t\t\t\t\t\tif (prop in configurations[k]) {\n\t\t\t\t\t\t\to[prop] = configurations[k][prop];\n\t\t\t\t\t\t\tupdate_prop_num++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\to[prop] = this._configurations[k][prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (update_prop_num > 0) {\n\t\t\t\t\t\tupdate_conf[k] = o;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (Object.keys(update_conf).length === 0) {\n\t\t\t\treject(new Error('No configuraion value is specified in the parameters.'));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Set Camera Angle\n\t\t\treturn this._setConfigurationsRequest(0x01, update_conf['cameraAngle']);\n\t\t}).then(() => {\n\t\t\t// Set Threshold Values\n\t\t\treturn this._setConfigurationsRequest(0x05, update_conf['threshold']);\n\t\t}).then(() => {\n\t\t\t// Set Detection Size\n\t\t\treturn this._setConfigurationsRequest(0x07, update_conf['detectionSize']);\n\t\t}).then(() => {\n\t\t\t// Set Face Angle\n\t\t\treturn this._setConfigurationsRequest(0x09, update_conf['faceAngle']);\n\t\t}).then(() => {\n\t\t\t// Get the latest configurations\n\t\t\treturn this.getConfigurations({ cache: false });\n\t\t}).then(new_conf => {\n\t\t\tresolve(new_conf);\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"561:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\nHvcP2.prototype._setConfigurationsRequest = function (command_number, conf) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tif (!conf || typeof conf !== 'object') {\n\t\t\tresolve();\n\t\t\treturn;\n\t\t}\n\t\tthis.request(command_number, conf).then(res => {\n\t\t\tresolve();\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"578:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: resetConfigurations()\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.resetConfigurations = function () {\n\tlet promise = new Promise((resolve, reject) => {\n\t\t// Set Camera Angle\n\t\tthis._setConfigurationsRequest(0x01, this._DEFAULT_CONFIGURATIONS['cameraAngle']).then(() => {\n\t\t\t// Set Threshold Values\n\t\t\treturn this._setConfigurationsRequest(0x05, this._DEFAULT_CONFIGURATIONS['threshold']);\n\t\t}).then(() => {\n\t\t\t// Set Detection Size\n\t\t\treturn this._setConfigurationsRequest(0x07, this._DEFAULT_CONFIGURATIONS['detectionSize']);\n\t\t}).then(() => {\n\t\t\t// Set Face Angle\n\t\t\treturn this._setConfigurationsRequest(0x09, this._DEFAULT_CONFIGURATIONS['faceAngle']);\n\t\t}).then(() => {\n\t\t\t// Get the latest configurations\n\t\t\treturn this.getConfigurations({ cache: false });\n\t\t}).then(new_conf => {\n\t\t\tresolve(new_conf);\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"607:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: saveAlbum(params)\r\n* - params  | optional | Object |\r\n*   - path  | optional | String | File path\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.saveAlbum = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tlet path = '';\n\t\tif (params) {\n\t\t\tif (typeof params !== 'object') {\n\t\t\t\treject(new Error('The argument `params` is invalid.'));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ('path' in params) {\n\t\t\t\tlet v = params['path'];\n\t\t\t\tif (typeof v !== 'string' || v === '') {\n\t\t\t\t\treject(new Error('The parameter `path` must be a string representing a file path.'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpath = v;\n\t\t\t}\n\t\t}\n\n\t\tthis.request(0x20, null).then(res => {\n\t\t\tlet buf = res['album'];\n\t\t\tif (path) {\n\t\t\t\tmFs.open(path, 'w', (error, fd) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmFs.write(fd, buf, 0, buf.length, null, error => {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmFs.close(fd, () => {\n\t\t\t\t\t\t\t\t\tresolve(res);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tresolve(res);\n\t\t\t}\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"660:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: loadAlbum(params)\r\n* - params   | requreid | Object |\r\n*   - buffer | optional | Buffer | Buffer object\r\n*   - path   | optional | String | File path\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.loadAlbum = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tlet buffer = null;\n\t\tlet path = '';\n\t\tif (params) {\n\t\t\tif (typeof params !== 'object') {\n\t\t\t\treject(new Error('The argument `params` is invalid.'));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ('buffer' in params) {\n\t\t\t\tlet v = params['buffer'];\n\t\t\t\tif (!Buffer.isBuffer(v)) {\n\t\t\t\t\treject(new Error('The parameter `buffer` must be a Buffer object.'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbuffer = v;\n\t\t\t}\n\t\t\tif (!buffer) {\n\t\t\t\tif ('path' in params) {\n\t\t\t\t\tlet v = params['path'];\n\t\t\t\t\tif (typeof v !== 'string' || v === '') {\n\t\t\t\t\t\treject(new Error('The parameter `path` must be a string representing a file path.'));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tpath = v;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treject(new Error('The argument `params` is required.'));\n\t\t\treturn;\n\t\t}\n\n\t\tif (path) {\n\t\t\tmFs.readFile(path, (error, data) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tthis.request(0x21, { album: data }).then(() => {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}).catch(error => {\n\t\t\t\t\t\tconsole.log(\"715:\");\n\t\t\t\t\t\tconsole.log(error);\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tthis.request(0x21, { album: buffer }).then(() => {\n\t\t\t\tresolve();\n\t\t\t}).catch(error => {\n\t\t\t\tconsole.log(\"723:\");\n\t\t\t\tconsole.log(error);\n\t\t\t\treject(error);\n\t\t\t});\n\t\t}\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: saveAlbumOnFlashROM()\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.saveAlbumOnFlashROM = function () {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tthis.request(0x22, null).then(() => {\n\t\t\tresolve();\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"741:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: reformatFlashROM()\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.reformatFlashROM = function () {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tthis.request(0x30, null).then(() => {\n\t\t\tresolve();\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"757:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: addFaceRecognitionData(params)\r\n* - params        | required    | Object |\r\n*   - userId      | required    | Number | 0 - 99\r\n*   - dataId      | required    | Number | 0-9\r\n*   - imageType   | optional    | Number | 0: Array (default), 1: Buffer, 2: Data URL, 3: File\r\n*   - imageFormat | optional    | String | \"gif\" (default), \"jpg\", or \"png\"\r\n*   - imagePath   | conditional | String | File path with file name (e.g., \"/tmp/image.png\")\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.addFaceRecognitionData = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tif (!params || typeof params !== 'object') {\n\t\t\treject(new Error('The argument `params` is invalid.'));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.request(0x10, {\n\t\t\tuserId: params['userId'],\n\t\t\tdataId: params['dataId']\n\t\t}).then(res => {\n\t\t\tresolve(res);\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"815:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: deleteFaceRecognitionData(params)\r\n* - params        | required    | Object |\r\n*   - userId      | required    | Number | 0 - 99\r\n*   - dataId      | required    | Number | 0-9\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.deleteFaceRecognitionData = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tif (!params || typeof params !== 'object') {\n\t\t\treject(new Error('The argument `params` is invalid.'));\n\t\t\treturn;\n\t\t}\n\t\tif (!('userId' in params)) {\n\t\t\treject(new Error('The parameter `userId` is required.'));\n\t\t\treturn;\n\t\t}\n\t\tif (this._user_id_list.indexOf(params['userId']) === -1) {\n\t\t\treject(new Error('The specified `userId` is not registered.'));\n\t\t\treturn;\n\t\t}\n\t\tthis.request(0x15, params).then(res => {\n\t\t\tif (res['dataIdList'].indexOf(params['dataId']) >= 0) {\n\t\t\t\tthis.request(0x11, params).then(() => {\n\t\t\t\t\tif (res['dataIdList'].length === 1) {\n\t\t\t\t\t\tlet new_user_id_list = [];\n\t\t\t\t\t\tthis._user_id_list.forEach(id => {\n\t\t\t\t\t\t\tif (id !== params['userId']) {\n\t\t\t\t\t\t\t\tnew_user_id_list.push(id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._user_id_list = new_user_id_list;\n\t\t\t\t\t}\n\t\t\t\t\tresolve();\n\t\t\t\t}).catch(error => {\n\t\t\t\t\tconsole.log(\"857:\");\n\t\t\t\t\tconsole.log(error);\n\t\t\t\t\treject(error);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treject(new Error('The specified `dataId` is not registered for the specified `userId`.'));\n\t\t\t}\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"865:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: deleteFaceRecognitionUser(params)\r\n* - params        | required    | Object |\r\n*   - userId      | required    | Number | 0 - 99\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.deleteFaceRecognitionUser = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tif (!params || typeof params !== 'object') {\n\t\t\treject(new Error('The argument `params` is invalid.'));\n\t\t\treturn;\n\t\t}\n\t\tif (!('userId' in params)) {\n\t\t\treject(new Error('The parameter `userId` is required.'));\n\t\t\treturn;\n\t\t}\n\t\tif (this._user_id_list.indexOf(params['userId']) === -1) {\n\t\t\treject(new Error('The specified `userId` is not registered.'));\n\t\t\treturn;\n\t\t}\n\t\tthis.request(0x12, params).then(() => {\n\t\t\tresolve();\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"895:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: clearFaceRecognitionData()\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.clearFaceRecognitionData = function () {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tthis.request(0x13, null).then(() => {\n\t\t\tresolve();\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"911:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: getFaceRecognitionData(params)\r\n* - params        | required    | Object |\r\n*   - userId      | required    | Number | 0 - 99\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.getFaceRecognitionData = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tif (!params || typeof params !== 'object') {\n\t\t\treject(new Error('The argument `params` is invalid.'));\n\t\t\treturn;\n\t\t}\n\t\tif (!('userId' in params)) {\n\t\t\treject(new Error('The parameter `userId` is required.'));\n\t\t\treturn;\n\t\t}\n\t\tif (this._user_id_list.indexOf(params['userId']) === -1) {\n\t\t\treject(new Error('The specified `userId` is not registered.'));\n\t\t\treturn;\n\t\t}\n\t\tthis.request(0x15, params).then(res => {\n\t\t\tresolve(res);\n\t\t}).catch(error => {\n\t\t\tconsole.log(\"941:\");\n\t\t\tconsole.log(error);\n\t\t\treject(error);\n\t\t});\n\t});\n\treturn promise;\n};\n\n/* ------------------------------------------------------------------\r\n* Method: getFaceRecognitionUsers([params])\r\n* - params  | optional | Object  |\r\n*   - cache | optional | Boolean | true (default) or false\r\n* ---------------------------------------------------------------- */\nHvcP2.prototype.getFaceRecognitionUsers = function (params) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tlet cache = true;\n\t\tif (params && typeof params === 'object') {\n\t\t\tif ('cache' in params) {\n\t\t\t\tlet v = params['cache'];\n\t\t\t\tif (typeof v === 'boolean') {\n\t\t\t\t\tcache = v;\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error('The parameter `cache` must be Boolean.'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cache === true) {\n\t\t\tresolve({ userIdList: this._user_id_list });\n\t\t\treturn;\n\t\t}\n\n\t\tlet user_id_list = [];\n\t\tlet id = 0;\n\t\tlet getData = cb => {\n\t\t\tthis.request(0x15, {\n\t\t\t\tuserId: id\n\t\t\t}).then(res => {\n\t\t\t\tif (res['dataIdList'].length > 0) {\n\t\t\t\t\tuser_id_list.push(id);\n\t\t\t\t}\n\t\t\t\tid++;\n\t\t\t\tif (id > 99) {\n\t\t\t\t\tcb();\n\t\t\t\t} else {\n\t\t\t\t\tgetData(cb);\n\t\t\t\t}\n\t\t\t}).catch(error => {\n\t\t\t\tconsole.log(\"989:\");\n\t\t\t\tconsole.log(error);\n\t\t\t\treject(error);\n\t\t\t});\n\t\t};\n\t\tgetData(() => {\n\t\t\tthis._user_id_list = user_id_list;\n\t\t\tresolve({\n\t\t\t\tuserIdList: JSON.parse(JSON.stringify(user_id_list))\n\t\t\t});\n\t\t});\n\t});\n\treturn promise;\n};\n\nmodule.exports = HvcP2;\n\n//# sourceURL=webpack:///./lib/HvcP2.js?");

/***/ }),

/***/ "./lib/HvcP2Command.js":
/*!*****************************!*\
  !*** ./lib/HvcP2Command.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* ------------------------------------------------------------------\r\n* node-omron-hvc-p2 - HvcP2Command.js\r\n* Date: 2018-02-27\r\n* ---------------------------------------------------------------- */\n\n\n/* ------------------------------------------------------------------\r\n* Constructor: HvcP2Image()\r\n* ---------------------------------------------------------------- */\n\nconst HvcP2Command = function () {\n\t// Public properties\n\n\t// Private properties\n\n};\n\n/* ------------------------------------------------------------------\r\n* Method: parse(cn, buf, params)\r\n* ---------------------------------------------------------------- */\nHvcP2Command.prototype.parse = function (cn, buf, params) {\n\tif (!buf || buf.length < 6 || buf.readUInt8(0) !== 0xFE) {\n\t\tconsole.log(buf);\n\t\treturn { error: new Error('Unexpected data was received. (1)') };\n\t}\n\tlet data_length = buf.readInt32LE(2);\n\t//console.log(\"DATA_LENGTH:\"+data_length);\n\t//console.log(\"DATA_LENGTH+6:\"+(data_length + 6))\n\t//console.log(\"BUF_LENGTH:\"+buf.length);\n\n\t// Not sure why - but this is funky for the image parsing with buffer style enabled.... need to check against all features!\n\tif (buf.length !== data_length + 6) {\n\t\tconsole.log(buf);\n\t\t//return {error: new Error('Unexpected data was received. (2)')};\n\t}\n\tlet code = buf.readUInt8(1);\n\tif (code > 0) {\n\t\tlet message = this._getResponseCodeMessage(code) + ' (0x' + buf.slice(1, 2).toString('hex') + ')';\n\t\treturn { error: new Error(message) };\n\t}\n\n\tlet dbuf = buf.slice(6);\n\tlet parsed = null;\n\tif (cn === 0x00) {\n\t\t// Get Model and Version\n\t\tparsed = this._parse00(dbuf);\n\t} else if (cn === 0x01) {\n\t\t// Set Camera Angle\n\t\tparsed = this._parse01(dbuf);\n\t} else if (cn === 0x02) {\n\t\t// Get Camera Angle\n\t\tparsed = this._parse02(dbuf);\n\t} else if (cn === 0x04) {\n\t\t// Execute detection\n\t\tparsed = this._parse04(dbuf, params);\n\t} else if (cn === 0x05) {\n\t\t// Set Threshold Values\n\t\tparsed = this._parse05(dbuf);\n\t} else if (cn === 0x06) {\n\t\t// Get Threshold Values\n\t\tparsed = this._parse06(dbuf);\n\t} else if (cn === 0x07) {\n\t\t// Set Detection Size\n\t\tparsed = this._parse07(dbuf);\n\t} else if (cn === 0x08) {\n\t\t// Get Detection Size\n\t\tparsed = this._parse08(dbuf);\n\t} else if (cn === 0x09) {\n\t\t// Set Face Angle\n\t\tparsed = this._parse09(dbuf);\n\t} else if (cn === 0x0A) {\n\t\t// Get Face Angle\n\t\tparsed = this._parse0A(dbuf);\n\t} else if (cn === 0x10) {\n\t\t// Register Data (Face Recognition)\n\t\tparsed = this._parse10(dbuf);\n\t} else if (cn === 0x11) {\n\t\t// Delete Specified Data (Face Recognition)\n\t\tparsed = this._parse11(dbuf);\n\t} else if (cn === 0x12) {\n\t\t// Delete Specified User (Face Recognition)\n\t\tparsed = this._parse12(dbuf);\n\t} else if (cn === 0x13) {\n\t\t// Delete All Data (Face Recognition)\n\t\tparsed = this._parse13(dbuf);\n\t} else if (cn === 0x15) {\n\t\t// Get Registration Info (Face Recognition)\n\t\tparsed = this._parse15(dbuf);\n\t} else if (cn === 0x20) {\n\t\t// Save Album (Face Recognition)\n\t\tparsed = this._parse20(dbuf);\n\t} else if (cn === 0x21) {\n\t\t// Load Album (Face Recognition)\n\t\tparsed = this._parse21(dbuf);\n\t} else if (cn === 0x22) {\n\t\t// Save Album in Flash ROM (Face Recognition)\n\t\tparsed = this._parse22(dbuf);\n\t} else if (cn === 0x30) {\n\t\t// Reformat Flash ROM (Face Recognition)\n\t\tparsed = this._parse30(dbuf);\n\t} else {\n\t\treturn { error: new Error('Unknown command number: 0x' + Buffer.from([cn]).toString('hex')) };\n\t}\n\n\tif (parsed['data']) {\n\t\treturn { data: parsed['data'] };\n\t} else if (parsed['error']) {\n\t\treturn { error: parsed['error'] };\n\t} else {\n\t\treturn { error: new Error('Failed to parse the received data.') };\n\t}\n};\n\n/* ------------------------------------------------------------------\r\n* Method: create(cn, params)\r\n* ---------------------------------------------------------------- */\nHvcP2Command.prototype.create = function (cn, params) {\n\tif (cn == 0x00) {\n\t\t// Get Model and Version\n\t\treturn this._create00(params);\n\t} else if (cn === 0x01) {\n\t\t// Set Camera Angle\n\t\treturn this._create01(params);\n\t} else if (cn === 0x02) {\n\t\t// Get Camera Angle\n\t\treturn this._create02(params);\n\t} else if (cn === 0x04) {\n\t\t// Execute detection\n\t\treturn this._create04(params);\n\t} else if (cn === 0x05) {\n\t\t// Set Threshold Values\n\t\treturn this._create05(params);\n\t} else if (cn === 0x06) {\n\t\t// Get Threshold Values\n\t\treturn this._create06(params);\n\t} else if (cn === 0x07) {\n\t\t// Set Detection Size\n\t\treturn this._create07(params);\n\t} else if (cn === 0x08) {\n\t\t// Get Detection Size\n\t\treturn this._create08(params);\n\t} else if (cn === 0x09) {\n\t\t// Set Face Angle\n\t\treturn this._create09(params);\n\t} else if (cn === 0x0A) {\n\t\t// Get Face Angle\n\t\treturn this._create0A(params);\n\t} else if (cn === 0x10) {\n\t\t// Register Data (Face Recognition)\n\t\treturn this._create10(params);\n\t} else if (cn === 0x11) {\n\t\t// Delete Specified Data (Face Recognition)\n\t\treturn this._create11(params);\n\t} else if (cn === 0x12) {\n\t\t// Delete Specified User (Face Recognition)\n\t\treturn this._create12(params);\n\t} else if (cn === 0x13) {\n\t\t// Delete All Data (Face Recognition)\n\t\treturn this._create13(params);\n\t} else if (cn === 0x15) {\n\t\t// Get Registration Info (Face Recognition)\n\t\treturn this._create15(params);\n\t} else if (cn === 0x20) {\n\t\t// Save Album (Face Recognition)\n\t\treturn this._create20(params);\n\t} else if (cn === 0x21) {\n\t\t// Load Album (Face Recognition)\n\t\treturn this._create21(params);\n\t} else if (cn === 0x22) {\n\t\t// Save Album in Flash ROM (Face Recognition)\n\t\treturn this._create22(params);\n\t} else if (cn === 0x30) {\n\t\t// Reformat Flash ROM (Face Recognition)\n\t\treturn this._create30(params);\n\t} else {\n\t\treturn { error: new Error('Unknown command number.') };\n\t}\n};\n\nHvcP2Command.prototype._getResponseCodeMessage = function (rcode) {\n\tif (rcode === 0x00) {\n\t\treturn 'Normal end';\n\t} else if (rcode === 0x01) {\n\t\treturn 'Number of faces that can be registered is 0 (for Registration command only)';\n\t} else if (rcode === 0x02) {\n\t\treturn 'Number of detected faces is 2 or more (for Registration command only)';\n\t} else if (rcode === 0xFF) {\n\t\treturn 'Undefined error (this happens when an unlisted command is received)';\n\t} else if (rcode === 0xFE) {\n\t\treturn 'Internal error';\n\t} else if (rcode === 0xFD) {\n\t\treturn 'Improper command';\n\t} else if (rcode >= 0xFA && rcode <= 0xFC) {\n\t\treturn 'Transmission error';\n\t} else if (rcode >= 0xF0 && rcode <= 0xF0) {\n\t\treturn 'Device error';\n\t} else if (rcode >= 0xC0 && rcode <= 0xDF) {\n\t\treturn 'Face Recognition data error';\n\t} else {\n\t\treturn 'Unknown error';\n\t}\n};\n\n// Get Model and Version\nHvcP2Command.prototype._parse00 = function (buf) {\n\tif (buf.length === 19) {\n\t\treturn {\n\t\t\tdata: {\n\t\t\t\tmodel: buf.slice(0, 12).toString('ascii').replace(/\\s*$/, ''),\n\t\t\t\tmajor: buf.readUInt8(12),\n\t\t\t\tminor: buf.readUInt8(13),\n\t\t\t\trelease: buf.readUInt8(14),\n\t\t\t\trevision: buf.readUInt32LE(15)\n\t\t\t}\n\t\t};\n\t} else {\n\t\treturn { error: new Error('Parse error: The data is not for the command number `0x00`.') };\n\t}\n};\n\nHvcP2Command.prototype._create00 = function () {\n\tlet buf = Buffer.from([0xFE, 0x00, 0x00, 0x00]);\n\treturn { buffer: buf };\n};\n\n// Set Camera Angle\nHvcP2Command.prototype._parse01 = function (buf) {\n\treturn { data: {} };\n};\n\nHvcP2Command.prototype._create01 = function (params) {\n\t/*\r\n * - params        | required | Object |\r\n *   - angle       | required | Number | 0: 0º, 1: 90º, 2: 180º, 3: 270º\r\n */\n\tif (!params || typeof params !== 'object') {\n\t\treturn { error: new Error('Invalid parameter.') };\n\t}\n\tif (!('angle' in params)) {\n\t\treturn { error: new Error('The parameter `angle` is required.') };\n\t}\n\tlet angle = params['angle'];\n\tif (typeof angle !== 'number' || !angle.toString().match(/^(0|1|2|3)$/)) {\n\t\treturn { error: new Error('The parameter `angle` must be 0, 1, 2, or 3.') };\n\t}\n\n\tlet buf = Buffer.from([0xFE, 0x01, 0x01, 0x00, angle]);\n\treturn { buffer: buf };\n};\n\n// Get Camera Angle\nHvcP2Command.prototype._parse02 = function (buf) {\n\tif (buf.length === 1) {\n\t\treturn {\n\t\t\tdata: {\n\t\t\t\tangle: buf.readUInt8(0)\n\t\t\t}\n\t\t};\n\t} else {\n\t\treturn { error: new Error('Parse error: The data is not for the command number `0x02`.') };\n\t}\n};\n\nHvcP2Command.prototype._create02 = function () {\n\tlet buf = Buffer.from([0xFE, 0x02, 0x00, 0x00]);\n\treturn { buffer: buf };\n};\n\n// Execute detection\nHvcP2Command.prototype._parse04 = function (buf, p) {\n\t/*\r\n * - params        | required | Object |\r\n *   - body        | optional | Number | Human Body Detection (0: disable, 1: enable)\r\n *   - hand        | optional | Number | Hand Detection (0: disable, 1: enable)\r\n *   - face        | optional | Number | Face Detection (0: disable, 1: enable)\r\n *   - direction   | optional | Number | Face Direction Estimation (0: disable, 1: enable)\r\n *   - age         | optional | Number | Age Estimation (0: disable, 1: enable)\r\n *   - gender      | optional | Number | Gender Estimation (0: disable, 1: enable)\r\n *   - gaze        | optional | Number | Gaze Estimation (0: disable, 1: enable)\r\n *   - blink       | optional | Number | Blink Estimation (0: disable, 1: enable)\r\n *   - expression  | optional | Number | Expression Estimation (0: disable, 1: enable)\r\n *   - recognition | optional | Number | Face Recognition (0: disable, 1: enable)\r\n *   - image       | optional | Number | Image output (0: disable, 1: 320x240 pixel, 2: 160x120 pixel)\r\n */\n\n\t//console.log(buf);\n\n\t// Check the length of the response data\n\tif (buf.length < 4) {\n\t\treturn { error: new Error('The length of the response data is too short for the command `0x04`.') };\n\t}\n\n\tlet h = {\n\t\tbody: buf.readUInt8(0),\n\t\thand: buf.readUInt8(1),\n\t\tface: buf.readUInt8(2)\n\t};\n\n\tlet expected_len = 4 + h['body'] * 8 + h['hand'] * 8;\n\n\tif (h['face']) {\n\t\tlet face_len_each = 0;\n\t\tif (p['face']) {\n\t\t\tface_len_each += 8;\n\t\t}\n\t\tif (p['direction']) {\n\t\t\tface_len_each += 8;\n\t\t}\n\t\tif (p['age']) {\n\t\t\tface_len_each += 3;\n\t\t}\n\t\tif (p['gender']) {\n\t\t\tface_len_each += 3;\n\t\t}\n\t\tif (p['gaze']) {\n\t\t\tface_len_each += 2;\n\t\t}\n\t\tif (p['blink']) {\n\t\t\tface_len_each += 4;\n\t\t}\n\t\tif (p['expression']) {\n\t\t\tface_len_each += 6;\n\t\t}\n\t\tif (p['recognition']) {\n\t\t\tface_len_each += 4;\n\t\t}\n\t\tlet face_len = face_len_each * h['face'];\n\t\texpected_len += face_len;\n\t}\n\n\tif (p['image'] === 1) {\n\t\texpected_len += 76804;\n\t} else if (p['image'] === 2) {\n\t\texpected_len += 19204;\n\t}\n\n\tif (buf.length !== expected_len) {\n\t\t//console.log(typeof buf)\n\t\t//console.log(buf.length);\n\t\t//console.log(buf);\n\t\tconsole.log(\"IMAGE BUFFER ERROR - UNEXPECTED LENGTH - let it parse anyway…\");\n\t\t// may need to revisit and flag this as bad depending on how it affects rest of data - double check.\n\t\t//return {error: new Error('The length of the response data is wrong for the command `0x04`.')};\n\t\t// The errors where the length was changing are intermittent - could be the result of some other\n\t\t// part of the processes we are doing while leveraging this library, which might be causing timeouts - revisit\n\t\treturn { data: {} };\n\t\t/* If the above empty doesnt work - perhaps we pad or replace it?  Ideally, we should send back a result, but with no body\r\n  // hand, face, image data - and process/discard that frame...\r\n  if(buf.length === expected_len-4) {\r\n  \tbuf.write(\"0000\", buf.length+1);\r\n  }\r\n  */\n\t}\n\n\t// Parse the response data\n\tlet data = {};\n\tlet offset = 4;\n\n\t// Human Body Detection\n\tlet body = [];\n\tfor (let i = 0; i < h['body']; i++) {\n\t\tbody.push({\n\t\t\tx: buf.readInt16LE(offset + 0),\n\t\t\ty: buf.readInt16LE(offset + 2),\n\t\t\tsize: buf.readInt16LE(offset + 4),\n\t\t\tconfidence: buf.readInt16LE(offset + 6)\n\t\t});\n\t\toffset += 8;\n\t}\n\tif (p[`body`]) {\n\t\tdata['body'] = body;\n\t}\n\t// Hand Detection\n\tlet hand = [];\n\tfor (let i = 0; i < h['hand']; i++) {\n\t\thand.push({\n\t\t\tx: buf.readInt16LE(offset + 0),\n\t\t\ty: buf.readInt16LE(offset + 2),\n\t\t\tsize: buf.readInt16LE(offset + 4),\n\t\t\tconfidence: buf.readInt16LE(offset + 6)\n\t\t});\n\t\toffset += 8;\n\t}\n\tif (p['hand']) {\n\t\tdata['hand'] = hand;\n\t}\n\t// Face Detection\n\tlet face = [];\n\tfor (let i = 0; i < h['face']; i++) {\n\t\tlet d = {};\n\t\t// Face Detection\n\t\tif (p['face']) {\n\t\t\td['face'] = {\n\t\t\t\tx: buf.readInt16LE(offset + 0),\n\t\t\t\ty: buf.readInt16LE(offset + 2),\n\t\t\t\tsize: buf.readInt16LE(offset + 4),\n\t\t\t\tconfidence: buf.readInt16LE(offset + 6)\n\t\t\t};\n\t\t\toffset += 8;\n\t\t}\n\t\t// Face Direction Estimation\n\t\tif (p['direction']) {\n\t\t\td['direction'] = {\n\t\t\t\tyaw: buf.readInt16LE(offset + 0),\n\t\t\t\tpitch: buf.readInt16LE(offset + 2),\n\t\t\t\troll: buf.readInt16LE(offset + 4),\n\t\t\t\tconfidence: buf.readInt16LE(offset + 6)\n\t\t\t};\n\t\t\toffset += 8;\n\t\t}\n\t\t// Age Estimation\n\t\tif (p['age']) {\n\t\t\td['age'] = {\n\t\t\t\tage: buf.readInt8(offset + 0),\n\t\t\t\tconfidence: buf.readInt16LE(offset + 1)\n\t\t\t};\n\t\t\toffset += 3;\n\t\t}\n\t\t// Gender Estimation\n\t\tif (p['gender']) {\n\t\t\td['gender'] = {\n\t\t\t\tgender: buf.readInt8(offset + 0), // 0: Female, 1: Male\n\t\t\t\tconfidence: buf.readInt16LE(offset + 1)\n\t\t\t};\n\t\t\toffset += 3;\n\t\t}\n\t\t// Gaze Estimation\n\t\tif (p['gaze']) {\n\t\t\td['gaze'] = {\n\t\t\t\tyaw: buf.readInt8(offset + 0),\n\t\t\t\tpitch: buf.readInt8(offset + 1)\n\t\t\t};\n\t\t\toffset += 2;\n\t\t}\n\t\t// Blink Estimation\n\t\tif (p['blink']) {\n\t\t\td['blink'] = {\n\t\t\t\tleft: buf.readInt16LE(offset + 0),\n\t\t\t\tright: buf.readInt16LE(offset + 2)\n\t\t\t};\n\t\t\toffset += 4;\n\t\t}\n\t\t// Expression Estimation\n\t\tif (p['expression']) {\n\t\t\td['expression'] = {\n\t\t\t\tneutral: buf.readInt8(offset + 0),\n\t\t\t\thappiness: buf.readInt8(offset + 1),\n\t\t\t\tsurprise: buf.readInt8(offset + 2),\n\t\t\t\tanger: buf.readInt8(offset + 3),\n\t\t\t\tsadness: buf.readInt8(offset + 4),\n\t\t\t\tpositive: buf.readInt8(offset + 5)\n\t\t\t};\n\t\t\toffset += 6;\n\t\t}\n\t\t// Face Recognition\n\t\tif (p['recognition']) {\n\t\t\td['recognition'] = {\n\t\t\t\tuserId: buf.readInt16LE(offset + 0),\n\t\t\t\tscore: buf.readInt16LE(offset + 2)\n\t\t\t};\n\t\t\toffset += 4;\n\t\t}\n\t\tface.push(d);\n\t}\n\tif (p['face'] || p['direction'] || p['age'] || p['gender'] || p['gaze'] || p['blink'] || p['expression'] || p['recognition']) {\n\t\tdata['face'] = face;\n\t}\n\t// Image\n\tif (p['image']) {\n\t\tlet width = buf.readUInt16LE(offset + 0);\n\t\tlet height = buf.readUInt16LE(offset + 2);\n\t\tlet image_buf = buf.slice(offset + 4);\n\t\tlet pixels = [];\n\t\t// we could skip pixels and stay with the buffer if we move just to sharp - revisit\n\t\tfor (let i = 0; i < image_buf.length; i++) {\n\t\t\tpixels.push(image_buf.readUInt8(i));\n\t\t}\n\t\tdata['image'] = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tpixels: pixels,\n\t\t\tbuffer: image_buf\n\t\t};\n\t\tpixels = null;\n\t\timage_buf = null;\n\t}\n\t//\n\treturn { data: data };\n};\n\nHvcP2Command.prototype._create04 = function (params) {\n\t/*\r\n * - params        | required | Object |\r\n *   - body        | optional | Number | Human Body Detection (0: disable (default), 1: enable)\r\n *   - hand        | optional | Number | Hand Detection (0: disable (default), 1: enable)\r\n *   - face        | optional | Number | Face Detection (0: disable (default), 1: enable)\r\n *   - direction   | optional | Number | Face Direction Estimation (0: disable (default), 1: enable)\r\n *   - age         | optional | Number | Age Estimation (0: disable (default), 1: enable)\r\n *   - gender      | optional | Number | Gender Estimation (0: disable (default), 1: enable)\r\n *   - gaze        | optional | Number | Gaze Estimation (0: disable (default), 1: enable)\r\n *   - blink       | optional | Number | Blink Estimation (0: disable (default), 1: enable)\r\n *   - expression  | optional | Number | Expression Estimation (0: disable (default), 1: enable)\r\n *   - recognition | optional | Number | Face Recognition (0: disable (default), 1: enable)\r\n *   - image       | optional | Number | Image output (0: disable (default), 1: 320x240 pixel, 2: 160x120 pixel)\r\n */\n\n\tif (!params || typeof params !== 'object') {\n\t\treturn { error: new Error('Invalid parameter.') };\n\t}\n\tlet error = null;\n\tlet p = {};\n\t['body', 'hand', 'face', 'direction', 'age', 'gender', 'gaze', 'blink', 'expression', 'recognition'].forEach(k => {\n\t\tif (k in params) {\n\t\t\tlet v = params[k];\n\t\t\tif (typeof v === 'number' && v.toString().match(/^(0|1)$/)) {\n\t\t\t\tp[k] = v;\n\t\t\t} else {\n\t\t\t\terror = new Error('The parameter `' + k + '` must be 0 or 1.');\n\t\t\t}\n\t\t} else {\n\t\t\tp[k] = 0;\n\t\t}\n\t});\n\tif (error) {\n\t\treturn { error: error };\n\t}\n\n\tif ('image' in params) {\n\t\tlet v = params['image'];\n\t\tif (typeof v === 'number' && v.toString().match(/^(0|1|2)$/)) {\n\t\t\tp['image'] = v;\n\t\t} else {\n\t\t\terror = new Error('The parameter `' + k + '` must be 0, 1, or 2.');\n\t\t}\n\t} else {\n\t\tp['image'] = 0;\n\t}\n\n\tlet d1 = 0;\n\t['body', 'hand', 'face', 'direction', 'age', 'gender', 'gaze', 'blink'].forEach((k, i) => {\n\t\tif (p[k] === 1) {\n\t\t\td1 = d1 | 1 << i;\n\t\t}\n\t});\n\tlet d2 = 0;\n\t['expression', 'recognition'].forEach((k, i) => {\n\t\tif (p[k] === 1) {\n\t\t\td2 = d2 | 1 << i;\n\t\t}\n\t});\n\tlet d3 = p['image'];\n\n\tlet buf = Buffer.from([0xFE, 0x04, 0x03, 0x00, d1, d2, d3]);\n\treturn { buffer: buf };\n};\n\n// Set Threshold Values\nHvcP2Command.prototype._parse05 = function (buf) {\n\treturn { data: {} };\n};\n\nHvcP2Command.prototype._create05 = function (params) {\n\t/*\r\n * - params        | required | Object |\r\n *   - body        | optional | Number | Human Body Detection (1 - 1000)\r\n *   - hand        | optional | Number | Hand Detection (1 - 1000)\r\n *   - face        | optional | Number | Face Detection (1 - 1000)\r\n *   - recognition | optional | Number | Face Recognition (0 - 1000)\r\n */\n\n\tif (!params || typeof params !== 'object') {\n\t\treturn { error: new Error('Invalid parameter.') };\n\t}\n\tlet error = null;\n\tlet p = {};\n\t['body', 'hand', 'face', 'recognition'].forEach(k => {\n\t\tif (k in params) {\n\t\t\tlet v = params[k];\n\t\t\tlet min = k === 'recognition' ? 0 : 1;\n\t\t\tif (typeof v === 'number' && v >= min && v <= 1000 && v % 1 === 0) {\n\t\t\t\tp[k] = v;\n\t\t\t} else {\n\t\t\t\terror = new Error('The parameter `' + k + '` must be an integer between ' + min + ' and 1000.');\n\t\t\t}\n\t\t} else {\n\t\t\tp[k] = 500;\n\t\t}\n\t});\n\tif (error) {\n\t\treturn { error: error };\n\t}\n\n\tlet buf1 = Buffer.from([0xFE, 0x05, 0x08, 0x00]);\n\tlet buf2 = Buffer.alloc(8);\n\t['body', 'hand', 'face', 'recognition'].forEach((k, i) => {\n\t\tbuf2.writeUInt16LE(p[k], i * 2);\n\t});\n\tlet buf = Buffer.concat([buf1, buf2]);\n\treturn { buffer: buf };\n};\n\n// Get Threshold Values\nHvcP2Command.prototype._parse06 = function (buf) {\n\tif (buf.length === 8) {\n\t\treturn {\n\t\t\tdata: {\n\t\t\t\tbody: buf.readUInt16LE(0),\n\t\t\t\thand: buf.readUInt16LE(2),\n\t\t\t\tface: buf.readUInt16LE(4),\n\t\t\t\trecognition: buf.readUInt16LE(6)\n\t\t\t}\n\t\t};\n\t} else {\n\t\treturn { error: new Error('Parse error: The data is not for the command number `0x06`.') };\n\t}\n};\n\nHvcP2Command.prototype._create06 = function () {\n\tlet buf = Buffer.from([0xFE, 0x06, 0x00, 0x00]);\n\treturn { buffer: buf };\n};\n\n// Set Detection Size\nHvcP2Command.prototype._parse07 = function (buf) {\n\treturn { data: {} };\n};\n\nHvcP2Command.prototype._create07 = function (params) {\n\t/*\r\n * - params    | required | Object |\r\n *   - bodyMin | optional | Number | Human Body Detection (20 - 8192)\r\n *   - bodyMax | optional | Number | Human Body Detection (20 - 8192)\r\n *   - handMin | optional | Number | Hand Detection (20 - 8192)\r\n *   - handMax | optional | Number | Hand Detection (20 - 8192)\r\n *   - faceMin | optional | Number | Face Detection (20 - 8192)\r\n *   - faceMax | optional | Number | Face Detection (20 - 8192)\r\n */\n\n\tif (!params || typeof params !== 'object') {\n\t\treturn { error: new Error('Invalid parameter.') };\n\t}\n\tlet error = null;\n\tlet p = {};\n\tlet defaults = {\n\t\tbodyMin: 30,\n\t\tbodyMax: 8192,\n\t\thandMin: 40,\n\t\thandMax: 8192,\n\t\tfaceMin: 64,\n\t\tfaceMax: 8192\n\t};\n\t['bodyMin', 'bodyMax', 'handMin', 'handMax', 'faceMin', 'faceMax'].forEach(k => {\n\t\tif (k in params) {\n\t\t\tlet v = params[k];\n\t\t\tif (typeof v === 'number' && v >= 20 && v <= 8192 && v % 1 === 0) {\n\t\t\t\tp[k] = v;\n\t\t\t} else {\n\t\t\t\terror = new Error('The parameter `' + k + '` must be an integer between 20 and 8192.');\n\t\t\t}\n\t\t} else {\n\t\t\tp[k] = defaults[k];\n\t\t}\n\t});\n\tif (error) {\n\t\treturn { error: error };\n\t}\n\n\t['body', 'hand', 'face'].forEach(k => {\n\t\tif (p[k + 'Min'] > p[k + 'Max']) {\n\t\t\terror = new Error('The `' + k + 'Min` must be less than or equal to the `' + k + 'Max`.');\n\t\t}\n\t});\n\tif (error) {\n\t\treturn { error: error };\n\t}\n\n\tlet buf1 = Buffer.from([0xFE, 0x07, 0x0C, 0x00]);\n\tlet buf2 = Buffer.alloc(12);\n\t['body', 'hand', 'face'].forEach((k, i) => {\n\t\tbuf2.writeUInt16LE(p[k + 'Min'], i * 4);\n\t\tbuf2.writeUInt16LE(p[k + 'Max'], i * 4 + 2);\n\t});\n\tlet buf = Buffer.concat([buf1, buf2]);\n\treturn { buffer: buf };\n};\n\n// Get Detection Size\nHvcP2Command.prototype._parse08 = function (buf) {\n\tif (buf.length === 12) {\n\t\treturn {\n\t\t\tdata: {\n\t\t\t\tbodyMin: buf.readUInt16LE(0),\n\t\t\t\tbodyMax: buf.readUInt16LE(2),\n\t\t\t\thandMin: buf.readUInt16LE(4),\n\t\t\t\thandMax: buf.readUInt16LE(6),\n\t\t\t\tfaceMin: buf.readUInt16LE(8),\n\t\t\t\tfaceMax: buf.readUInt16LE(10)\n\t\t\t}\n\t\t};\n\t} else {\n\t\treturn { error: new Error('Parse error: The data is not for the command number `0x08`.') };\n\t}\n};\n\nHvcP2Command.prototype._create08 = function () {\n\tlet buf = Buffer.from([0xFE, 0x08, 0x00, 0x00]);\n\treturn { buffer: buf };\n};\n\n// Set Face Angle\nHvcP2Command.prototype._parse09 = function (buf) {\n\treturn { data: {} };\n};\n\nHvcP2Command.prototype._create09 = function (params) {\n\t/*\r\n * - params | required | Object |\r\n *   - yaw  | optional | Number | Yaw angle range (0: ±30º, 1: ±60º, 2: ±90º)\r\n *   - roll | optional | Number | Roll angle range (0: ±15º, 1: ±45º)\r\n */\n\tif (!params || typeof params !== 'object') {\n\t\treturn { error: new Error('Invalid parameter.') };\n\t}\n\tlet p = {};\n\tif ('yaw' in params) {\n\t\tlet v = params['yaw'];\n\t\tif (typeof v === 'number' && v.toString().match(/^(0|1|2)$/)) {\n\t\t\tp['yaw'] = v;\n\t\t} else {\n\t\t\treturn { error: new Error('The parameter `yaw` must be 0, 1, or 2.') };\n\t\t}\n\t} else {\n\t\tp['yaw'] = 0;\n\t}\n\tif ('roll' in params) {\n\t\tlet v = params['roll'];\n\t\tif (typeof v === 'number' && v.toString().match(/^(0|1)$/)) {\n\t\t\tp['roll'] = v;\n\t\t} else {\n\t\t\treturn { error: new Error('The parameter `roll` must be 0 or 1.') };\n\t\t}\n\t} else {\n\t\tp['roll'] = 0;\n\t}\n\tlet buf = Buffer.from([0xFE, 0x09, 0x02, 0x00, p['yaw'], p['roll']]);\n\treturn { buffer: buf };\n};\n\n// Get Face Angle\nHvcP2Command.prototype._parse0A = function (buf) {\n\tif (buf.length === 2) {\n\t\treturn {\n\t\t\tdata: {\n\t\t\t\tyaw: buf.readUInt8(0),\n\t\t\t\troll: buf.readUInt8(1)\n\t\t\t}\n\t\t};\n\t} else {\n\t\treturn { error: new Error('Parse error: The data is not for the command number `0x0A`.') };\n\t}\n};\n\nHvcP2Command.prototype._create0A = function () {\n\tlet buf = Buffer.from([0xFE, 0x0A, 0x00, 0x00]);\n\treturn { buffer: buf };\n};\n\n// Register Data (Face Recognition)\nHvcP2Command.prototype._parse10 = function (buf) {\n\tif (buf.length === 4100) {\n\t\tlet width = buf.readUInt16LE(0);\n\t\tlet height = buf.readUInt16LE(2);\n\t\tlet pixels = [];\n\t\tfor (let i = 4; i < buf.length; i++) {\n\t\t\tpixels.push(buf.readUInt8(i));\n\t\t}\n\t\treturn {\n\t\t\tdata: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tpixels: pixels\n\t\t\t}\n\t\t};\n\t} else {\n\t\treturn { error: new Error('Parse error: The data is not for the command number `0x10`.') };\n\t}\n};\n\nHvcP2Command.prototype._create10 = function (params) {\n\t/*\r\n * - params   | required | Object |\r\n *   - userId | required | Number | 0 - 99\r\n *   - dataId | required | Number | 0-9\r\n */\n\tif (!params || typeof params !== 'object') {\n\t\treturn { error: new Error('Invalid parameter.') };\n\t}\n\tlet p = {};\n\tif ('userId' in params) {\n\t\tlet v = params['userId'];\n\t\tif (typeof v === 'number' && v >= 0 && v <= 99 && v % 1 === 0) {\n\t\t\tp['userId'] = v;\n\t\t} else {\n\t\t\treturn { error: new Error('The parameter `userId` must be an integer between 0 and 99.') };\n\t\t}\n\t} else {\n\t\treturn { error: new Error('The parameter `userId` is required') };\n\t}\n\tif ('dataId' in params) {\n\t\tlet v = params['dataId'];\n\t\tif (typeof v === 'number' && v >= 0 && v <= 9 && v % 1 === 0) {\n\t\t\tp['dataId'] = v;\n\t\t} else {\n\t\t\treturn { error: new Error('The parameter `dataId` must be an integer between 0 and 9.') };\n\t\t}\n\t} else {\n\t\treturn { error: new Error('The parameter `dataId` is required') };\n\t}\n\tlet buf1 = Buffer.from([0xFE, 0x10, 0x03, 0x00]);\n\tlet buf2 = Buffer.alloc(3);\n\tbuf2.writeUInt16LE(p['userId'], 0);\n\tbuf2.writeUInt8(p['dataId'], 2);\n\tlet buf = Buffer.concat([buf1, buf2]);\n\treturn { buffer: buf };\n};\n\n// Delete Specified Data (Face Recognition)\nHvcP2Command.prototype._parse11 = function (buf) {\n\treturn { data: {} };\n};\n\nHvcP2Command.prototype._create11 = function (params) {\n\t/*\r\n * - params   | required | Object |\r\n *   - userId | required | Number | 0 - 99\r\n *   - dataId | required | Number | 0-9\r\n */\n\tif (!params || typeof params !== 'object') {\n\t\treturn { error: new Error('Invalid parameter.') };\n\t}\n\tlet p = {};\n\tif ('userId' in params) {\n\t\tlet v = params['userId'];\n\t\tif (typeof v === 'number' && v >= 0 && v <= 99 && v % 1 === 0) {\n\t\t\tp['userId'] = v;\n\t\t} else {\n\t\t\treturn { error: new Error('The parameter `userId` must be an integer between 0 and 99.') };\n\t\t}\n\t} else {\n\t\treturn { error: new Error('The parameter `userId` is required') };\n\t}\n\tif ('dataId' in params) {\n\t\tlet v = params['dataId'];\n\t\tif (typeof v === 'number' && v >= 0 && v <= 9 && v % 1 === 0) {\n\t\t\tp['dataId'] = v;\n\t\t} else {\n\t\t\treturn { error: new Error('The parameter `dataId` must be an integer between 0 and 9.') };\n\t\t}\n\t} else {\n\t\treturn { error: new Error('The parameter `dataId` is required') };\n\t}\n\tlet buf1 = Buffer.from([0xFE, 0x11, 0x03, 0x00]);\n\tlet buf2 = Buffer.alloc(3);\n\tbuf2.writeUInt16LE(p['userId'], 0);\n\tbuf2.writeUInt8(p['dataId'], 2);\n\tlet buf = Buffer.concat([buf1, buf2]);\n\treturn { buffer: buf };\n};\n\n// Delete Specified User (Face Recognition)\nHvcP2Command.prototype._parse12 = function (buf) {\n\treturn { data: {} };\n};\n\nHvcP2Command.prototype._create12 = function (params) {\n\t/*\r\n * - params   | required | Object |\r\n *   - userId | required | Number | 0 - 99\r\n */\n\tif (!params || typeof params !== 'object') {\n\t\treturn { error: new Error('Invalid parameter.') };\n\t}\n\tlet p = {};\n\tif ('userId' in params) {\n\t\tlet v = params['userId'];\n\t\tif (typeof v === 'number' && v >= 0 && v <= 99 && v % 1 === 0) {\n\t\t\tp['userId'] = v;\n\t\t} else {\n\t\t\treturn { error: new Error('The parameter `userId` must be an integer between 0 and 99.') };\n\t\t}\n\t} else {\n\t\treturn { error: new Error('The parameter `userId` is required') };\n\t}\n\tlet buf1 = Buffer.from([0xFE, 0x12, 0x02, 0x00]);\n\tlet buf2 = Buffer.alloc(2);\n\tbuf2.writeUInt16LE(p['userId'], 0);\n\tlet buf = Buffer.concat([buf1, buf2]);\n\treturn { buffer: buf };\n};\n\n// Delete All Data (Face Recognition)\nHvcP2Command.prototype._parse13 = function (buf) {\n\treturn { data: {} };\n};\n\nHvcP2Command.prototype._create13 = function () {\n\tlet buf = Buffer.from([0xFE, 0x13, 0x00, 0x00]);\n\treturn { buffer: buf };\n};\n\n// Get Registration Info (Face Recognition)\nHvcP2Command.prototype._parse15 = function (buf) {\n\tif (buf.length === 2) {\n\t\tlet list = [];\n\t\tlet d1 = buf.readUInt8(0);\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tif (d1 & 1 << i) {\n\t\t\t\tlist.push(i);\n\t\t\t}\n\t\t}\n\t\tlet d2 = buf.readUInt8(1);\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tif (d2 & 1 << i) {\n\t\t\t\tlist.push(i + 8);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tdata: {\n\t\t\t\tdataIdList: list\n\t\t\t}\n\t\t};\n\t} else {\n\t\treturn { error: new Error('Parse error: The data is not for the command number `0x15`.') };\n\t}\n};\n\nHvcP2Command.prototype._create15 = function (params) {\n\t/*\r\n * - params   | required | Object |\r\n *   - userId | required | Number | 0 - 99\r\n */\n\tif (!params || typeof params !== 'object') {\n\t\treturn { error: new Error('Invalid parameter.') };\n\t}\n\tlet p = {};\n\tif ('userId' in params) {\n\t\tlet v = params['userId'];\n\t\tif (typeof v === 'number' && v >= 0 && v <= 99 && v % 1 === 0) {\n\t\t\tp['userId'] = v;\n\t\t} else {\n\t\t\treturn { error: new Error('The parameter `userId` must be an integer between 0 and 99.') };\n\t\t}\n\t} else {\n\t\treturn { error: new Error('The parameter `userId` is required') };\n\t}\n\tlet buf1 = Buffer.from([0xFE, 0x15, 0x02, 0x00]);\n\tlet buf2 = Buffer.alloc(2);\n\tbuf2.writeUInt16LE(p['userId'], 0);\n\tlet buf = Buffer.concat([buf1, buf2]);\n\treturn { buffer: buf };\n};\n\n// Save Album (Face Recognition)\nHvcP2Command.prototype._parse20 = function (buf) {\n\tif (buf.length >= 0x28 && buf.length <= 0x027E5C) {\n\t\treturn {\n\t\t\tdata: {\n\t\t\t\talbum: buf\n\t\t\t}\n\t\t};\n\t} else {\n\t\treturn { error: new Error('Parse error: The data is not for the command number `0x20`.') };\n\t}\n};\n\nHvcP2Command.prototype._create20 = function () {\n\tlet buf = Buffer.from([0xFE, 0x20, 0x00, 0x00]);\n\treturn { buffer: buf };\n};\n\n// Load Album (Face Recognition)\nHvcP2Command.prototype._parse21 = function (buf) {\n\treturn { data: {} };\n};\n\nHvcP2Command.prototype._create21 = function (params) {\n\t/*\r\n * - params   | required | Object |\r\n *   - album  | required | Buffer |\r\n */\n\tif (!params || typeof params !== 'object') {\n\t\treturn { error: new Error('Invalid parameter.') };\n\t}\n\tlet p = {};\n\tif ('album' in params) {\n\t\tlet v = params['album'];\n\t\tif (Buffer.isBuffer(v)) {\n\t\t\tp['album'] = v;\n\t\t} else {\n\t\t\treturn { error: new Error('The parameter `album` must be a `Buffer` object.') };\n\t\t}\n\t} else {\n\t\treturn { error: new Error('The parameter `album` is required') };\n\t}\n\tlet buf1 = Buffer.from([0xFE, 0x21, 0x04, 0x00]);\n\tlet buf2 = Buffer.alloc(4);\n\tbuf2.writeUInt32LE(p['album'].length, 0);\n\tlet buf = Buffer.concat([buf1, buf2, p['album']]);\n\treturn { buffer: buf };\n};\n\n// Save Album in Flash ROM (Face Recognition)\nHvcP2Command.prototype._parse22 = function (buf) {\n\treturn { data: {} };\n};\n\nHvcP2Command.prototype._create22 = function () {\n\tlet buf = Buffer.from([0xFE, 0x22, 0x00, 0x00]);\n\treturn { buffer: buf };\n};\n\n// Reformat Flash ROM (Face Recognition)\nHvcP2Command.prototype._parse30 = function (buf) {\n\treturn { data: {} };\n};\n\nHvcP2Command.prototype._create30 = function () {\n\tlet buf = Buffer.from([0xFE, 0x30, 0x00, 0x00]);\n\treturn { buffer: buf };\n};\n\nmodule.exports = new HvcP2Command();\n\n//# sourceURL=webpack:///./lib/HvcP2Command.js?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack:///external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "serialport":
/*!*****************************!*\
  !*** external "serialport" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"serialport\");\n\n//# sourceURL=webpack:///external_%22serialport%22?");

/***/ })

/******/ });